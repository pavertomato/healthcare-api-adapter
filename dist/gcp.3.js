/*! For license information please see gcp.3.js.LICENSE */
(this.gcp_jsonp=this.gcp_jsonp||[]).push([[3],{"./node_modules/css-loader/lib/url/escape.js":function(module,exports){eval("module.exports = function escape(url) {\n    if (typeof url !== 'string') {\n        return url\n    }\n    // If url is already wrapped in quotes, remove them\n    if (/^['\"].*['\"]$/.test(url)) {\n        url = url.slice(1, -1);\n    }\n    // Should url be wrapped?\n    // See https://drafts.csswg.org/css-values-3/#urls\n    if (/[\"'() \\t\\n]/.test(url)) {\n        return '\"' + url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n') + '\"'\n    }\n\n    return url\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvdXJsL2VzY2FwZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi91cmwvZXNjYXBlLmpzP2IwNDEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlc2NhcGUodXJsKSB7XG4gICAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB1cmxcbiAgICB9XG4gICAgLy8gSWYgdXJsIGlzIGFscmVhZHkgd3JhcHBlZCBpbiBxdW90ZXMsIHJlbW92ZSB0aGVtXG4gICAgaWYgKC9eWydcIl0uKlsnXCJdJC8udGVzdCh1cmwpKSB7XG4gICAgICAgIHVybCA9IHVybC5zbGljZSgxLCAtMSk7XG4gICAgfVxuICAgIC8vIFNob3VsZCB1cmwgYmUgd3JhcHBlZD9cbiAgICAvLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtMy8jdXJsc1xuICAgIGlmICgvW1wiJygpIFxcdFxcbl0vLnRlc3QodXJsKSkge1xuICAgICAgICByZXR1cm4gJ1wiJyArIHVybC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvXFxuL2csICdcXFxcbicpICsgJ1wiJ1xuICAgIH1cblxuICAgIHJldHVybiB1cmxcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/lib/url/escape.js\n")},"./node_modules/dicomweb-client/build/dicomweb-client.js":function(module,exports,__webpack_require__){eval("(function (global, factory) {\n   true ? factory(exports) :\n  undefined;\n}(this, (function (exports) { 'use strict';\n\n  function _typeof(obj) {\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  /**\n   * Converts a Uint8Array to a String.\n   * @param {Uint8Array} array that should be converted\n   * @param {Number} offset array offset in case only subset of array items should be extracted (default: 0)\n   * @param {Number} limit maximum number of array items that should be extracted (defaults to length of array)\n   * @returns {String}\n   */\n  function uint8ArrayToString(arr, offset, limit) {\n    offset = offset || 0;\n    limit = limit || arr.length - offset;\n    var str = '';\n\n    for (var i = offset; i < offset + limit; i++) {\n      str += String.fromCharCode(arr[i]);\n    }\n\n    return str;\n  }\n  /**\n   * Converts a String to a Uint8Array.\n   * @param {String} str string that should be converted\n   * @returns {Uint8Array}\n   */\n\n\n  function stringToUint8Array(str) {\n    var arr = new Uint8Array(str.length);\n\n    for (var i = 0, j = str.length; i < j; i++) {\n      arr[i] = str.charCodeAt(i);\n    }\n\n    return arr;\n  }\n  /**\n   * Identifies the boundary in a multipart/related message header.\n   * @param {String} header message header\n   * @returns {String} boundary\n   */\n\n\n  function identifyBoundary(header) {\n    var parts = header.split('\\r\\n');\n\n    for (var i = 0; i < parts.length; i++) {\n      if (parts[i].substr(0, 2) === '--') {\n        return parts[i];\n      }\n    }\n  }\n  /**\n   * Checks whether a given token is contained by a message at a given offset.\n   * @param {Uint8Array} message message content\n   * @param {Uint8Array} token substring that should be present\n   * @param {String} offset offset in message content from where search should start\n   * @returns {Boolean} whether message contains token at offset\n   */\n\n\n  function containsToken(message, token) {\n    var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    if (message + token.length > message.length) {\n      return false;\n    }\n\n    var index = offset;\n\n    for (var i = 0; i < token.length; i++) {\n      if (token[i] !== message[index++]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Finds a given token in a message at a given offset.\n   * @param {Uint8Array} message message content\n   * @param {Uint8Array} token substring that should be found\n   * @param {String} offset message body offset from where search should start\n   * @returns {Boolean} whether message has a part at given offset or not\n   */\n\n\n  function findToken(message, token) {\n    var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var messageLength = message.length;\n\n    for (var i = offset; i < messageLength; i++) {\n      // If the first value of the message matches\n      // the first value of the token, check if\n      // this is the full token.\n      if (message[i] === token[0]) {\n        if (containsToken(message, token, i)) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * @typedef {Object} MultipartEncodedData\n   * @property {ArrayBuffer} data The encoded Multipart Data\n   * @property {String} boundary The boundary used to divide pieces of the encoded data\n   */\n\n  /**\n   * Encode one or more DICOM datasets into a single body so it can be\n   * sent using the Multipart Content-Type.\n   *\n   * @param {ArrayBuffer[]} datasets Array containing each file to be encoded in the multipart body, passed as ArrayBuffers.\n   * @param {String} [boundary] Optional string to define a boundary between each part of the multipart body. If this is not specified, a random GUID will be generated.\n   * @return {MultipartEncodedData} The Multipart encoded data returned as an Object. This contains both the data itself, and the boundary string used to divide it.\n   */\n\n\n  function multipartEncode(datasets) {\n    var boundary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : guid();\n    var contentType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'application/dicom';\n    var contentTypeString = \"Content-Type: \".concat(contentType);\n    var header = \"\\r\\n--\".concat(boundary, \"\\r\\n\").concat(contentTypeString, \"\\r\\n\\r\\n\");\n    var footer = \"\\r\\n--\".concat(boundary, \"--\");\n    var headerArray = stringToUint8Array(header);\n    var footerArray = stringToUint8Array(footer);\n    var headerLength = headerArray.length;\n    var footerLength = footerArray.length;\n    var length = 0; // Calculate the total length for the final array\n\n    var contentArrays = datasets.map(function (datasetBuffer) {\n      var contentArray = new Uint8Array(datasetBuffer);\n      var contentLength = contentArray.length;\n      length += headerLength + contentLength + footerLength;\n      return contentArray;\n    }); // Allocate the array\n\n    var multipartArray = new Uint8Array(length); // Set the initial header\n\n    multipartArray.set(headerArray, 0); // Write each dataset into the multipart array\n\n    var position = 0;\n    contentArrays.forEach(function (contentArray) {\n      var contentLength = contentArray.length;\n      multipartArray.set(headerArray, position);\n      multipartArray.set(contentArray, position + headerLength);\n      position += headerLength + contentArray.length;\n    });\n    multipartArray.set(footerArray, position);\n    return {\n      data: multipartArray.buffer,\n      boundary: boundary\n    };\n  }\n  /**\n   * Decode a Multipart encoded ArrayBuffer and return the components as an Array.\n   *\n   * @param {ArrayBuffer} response Data encoded as a 'multipart/related' message\n   * @returns {Array} The content\n   */\n\n  function multipartDecode(response) {\n    var message = new Uint8Array(response); // First look for the multipart mime header\n\n    var separator = stringToUint8Array('\\r\\n\\r\\n');\n    var headerIndex = findToken(message, separator);\n\n    if (headerIndex === -1) {\n      throw new Error('Response message has no multipart mime header');\n    }\n\n    var header = uint8ArrayToString(message, 0, headerIndex);\n    var boundaryString = identifyBoundary(header);\n\n    if (!boundaryString) {\n      throw new Error('Header of response message does not specify boundary');\n    }\n\n    var boundary = stringToUint8Array(boundaryString);\n    var boundaryLength = boundary.length;\n    var components = [];\n    var offset = headerIndex + separator.length; // Loop until we cannot find any more boundaries\n\n    var boundaryIndex;\n\n    while (boundaryIndex !== -1) {\n      // Search for the next boundary in the message, starting\n      // from the current offset position\n      boundaryIndex = findToken(message, boundary, offset); // If no further boundaries are found, stop here.\n\n      if (boundaryIndex === -1) {\n        break;\n      } // Extract data from response message, excluding \"\\r\\n\"\n\n\n      var spacingLength = 2;\n      var length = boundaryIndex - offset - spacingLength;\n      var data = response.slice(offset, offset + length); // Add the data to the array of results\n\n      components.push(data); // Move the offset to the end of the current section,\n      // plus the identified boundary\n\n      offset += length + spacingLength + boundaryLength;\n    }\n\n    return components;\n  }\n  /**\n   * Create a random GUID\n   *\n   * @return {string}\n   */\n\n\n  function guid() {\n    function s4() {\n      return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n    }\n\n    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n  }\n\n  function isEmptyObject(obj) {\n    return Object.keys(obj).length === 0 && obj.constructor === Object;\n  }\n\n  var getFirstResult = function getFirstResult(result) {\n    return result[0];\n  };\n\n  var MIMETYPES = {\n    DICOM: 'application/dicom',\n    DICOM_JSON: 'application/dicom+json',\n    OCTET_STREAM: 'application/octet-stream'\n  };\n  /**\n  * Class for interacting with DICOMweb RESTful services.\n  */\n\n  var DICOMwebClient =\n  /*#__PURE__*/\n  function () {\n    /**\n    * @constructor\n    * @param {Object} options (choices: \"url\", \"username\", \"password\", \"headers\")\n    */\n    function DICOMwebClient(options) {\n      _classCallCheck(this, DICOMwebClient);\n\n      this.baseURL = options.url;\n\n      if (!this.baseURL) {\n        console.error('DICOMweb base url provided - calls will fail');\n      }\n\n      if ('username' in options) {\n        this.username = options.username;\n\n        if (!('password' in options)) {\n          console.error('no password provided to authenticate with DICOMweb service');\n        }\n\n        this.password = options.password;\n      }\n\n      this.headers = options.headers || {};\n    }\n\n    _createClass(DICOMwebClient, [{\n      key: \"_httpRequest\",\n      value: function _httpRequest(url, method, headers) {\n        var _this = this;\n\n        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        return new Promise(function (resolve, reject) {\n          var request = new XMLHttpRequest();\n          request.open(method, url, true);\n\n          if ('responseType' in options) {\n            request.responseType = options.responseType;\n          }\n\n          if (_typeof(headers) === 'object') {\n            Object.keys(headers).forEach(function (key) {\n              request.setRequestHeader(key, headers[key]);\n            });\n          } // now add custom headers from the user\n          // (e.g. access tokens)\n\n\n          var userHeaders = _this.headers;\n          Object.keys(userHeaders).forEach(function (key) {\n            request.setRequestHeader(key, userHeaders[key]);\n          }); // Event triggered when upload starts\n\n          request.onloadstart = function (event) {//console.log('upload started: ', url)\n          }; // Event triggered when upload ends\n\n\n          request.onloadend = function (event) {//console.log('upload finished')\n          }; // Handle response message\n\n\n          request.onreadystatechange = function (event) {\n            if (request.readyState === 4) {\n              if (request.status === 200) {\n                resolve(request.response);\n              } else if (request.status === 202) {\n                console.warn('some resources already existed: ', request);\n                resolve(request.response);\n              } else if (request.status === 204) {\n                console.warn('empty response for request: ', request);\n                resolve([]);\n              } else {\n                console.error('request failed: ', request);\n                var error = new Error('request failed');\n                error.request = request;\n                error.response = request.response;\n                error.status = request.status;\n                console.error(error);\n                console.error(error.response);\n                reject(error);\n              }\n            }\n          }; // Event triggered while download progresses\n\n\n          if ('progressCallback' in options) {\n            if (typeof options.progressCallback === 'function') {\n              request.onprogress = options.progressCallback;\n            }\n          } // request.onprogress = function (event) {\n          //   const loaded = progress.loaded;\n          //   let total;\n          //   let percentComplete;\n          //   if (progress.lengthComputable) {\n          //     total = progress.total;\n          //     percentComplete = Math.round((loaded / total) * 100);\n          //   j\n          //   // console.log('download progress: ', percentComplete, ' %');\n          //   return(percentComplete);\n          // };\n\n\n          if ('data' in options) {\n            request.send(options.data);\n          } else {\n            request.send();\n          }\n        });\n      }\n    }, {\n      key: \"_httpGet\",\n      value: function _httpGet(url, headers, responseType, progressCallback) {\n        return this._httpRequest(url, 'get', headers, {\n          responseType: responseType,\n          progressCallback: progressCallback\n        });\n      }\n    }, {\n      key: \"_httpGetApplicationJson\",\n      value: function _httpGetApplicationJson(url) {\n        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var progressCallback = arguments.length > 2 ? arguments[2] : undefined;\n\n        if (_typeof(params) === 'object') {\n          if (!isEmptyObject(params)) {\n            url += DICOMwebClient._parseQueryParameters(params);\n          }\n        }\n\n        var headers = {\n          'Accept': MIMETYPES.DICOM_JSON\n        };\n        var responseType = 'json';\n        return this._httpGet(url, headers, responseType, progressCallback);\n      }\n    }, {\n      key: \"_httpGetByMimeType\",\n      value: function _httpGetByMimeType(url, mimeType, params) {\n        var responseType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'arraybuffer';\n        var progressCallback = arguments.length > 4 ? arguments[4] : undefined;\n\n        if (_typeof(params) === 'object') {\n          if (!isEmptyObject(params)) {\n            url += DICOMwebClient._parseQueryParameters(params);\n          }\n        }\n\n        var headers = {\n          'Accept': \"multipart/related; type=\\\"\".concat(mimeType, \"\\\"\")\n        };\n        return this._httpGet(url, headers, responseType, progressCallback);\n      }\n    }, {\n      key: \"_httpPost\",\n      value: function _httpPost(url, headers, data, progressCallback) {\n        return this._httpRequest(url, 'post', headers, {\n          data: data,\n          progressCallback: progressCallback\n        });\n      }\n    }, {\n      key: \"_httpPostApplicationJson\",\n      value: function _httpPostApplicationJson(url, data, progressCallback) {\n        var headers = {\n          'Content-Type': MIMETYPES.DICOM_JSON\n        };\n        return this._httpPost(url, headers, data, progressCallback);\n      }\n      /**\n       * Searches for DICOM studies.\n       * @param {Object} options options object - \"queryParams\" optional query parameters (choices: \"fuzzymatching\", \"offset\", \"limit\" or any valid DICOM attribute identifier)\n       * @return {Array} study representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2)\n       */\n\n    }, {\n      key: \"searchForStudies\",\n      value: function searchForStudies() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        console.log('search for studies');\n        var url = this.baseURL + '/studies';\n\n        if ('queryParams' in options) {\n          url += DICOMwebClient._parseQueryParameters(options.queryParams);\n        }\n\n        return this._httpGetApplicationJson(url);\n      }\n      /**\n       * Retrieves metadata for a DICOM study.\n       * @param {String} studyInstanceUID Study Instance UID\n       * @returns {Array} metadata elements in DICOM JSON format for each instance belonging to the study\n       */\n\n    }, {\n      key: \"retrieveStudyMetadata\",\n      value: function retrieveStudyMetadata(options) {\n        if (!('studyInstanceUID' in options)) {\n          throw new Error('Study Instance UID is required for retrieval of study metadata');\n        }\n\n        console.log(\"retrieve metadata of study \".concat(options.studyInstanceUID));\n        var url = this.baseURL + '/studies/' + options.studyInstanceUID + '/metadata';\n        return this._httpGetApplicationJson(url);\n      }\n      /**\n       * Searches for DICOM series.\n       * @param {Object} options optional DICOM identifiers (choices: \"studyInstanceUID\")\n       * @param {Object} queryParams optional query parameters (choices: \"fuzzymatching\", \"offset\", \"limit\" or any valid DICOM attribute identifier)\n       * @returns {Array} series representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2a)\n       */\n\n    }, {\n      key: \"searchForSeries\",\n      value: function searchForSeries() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var url = this.baseURL;\n\n        if ('studyInstanceUID' in options) {\n          console.log(\"search series of study \".concat(options.studyInstanceUID));\n          url += '/studies/' + options.studyInstanceUID;\n        }\n\n        url += '/series';\n\n        if ('queryParams' in options) {\n          url += DICOMwebClient._parseQueryParameters(options.queryParams);\n        }\n\n        return this._httpGetApplicationJson(url);\n      }\n      /**\n       * Retrieves metadata for a DICOM series.\n       * @param {String} studyInstanceUID Study Instance UID\n       * @param {String} seriesInstanceUID Series Instance UID\n       * @returns {Array} metadata elements in DICOM JSON format for each instance belonging to the series\n       */\n\n    }, {\n      key: \"retrieveSeriesMetadata\",\n      value: function retrieveSeriesMetadata(options) {\n        if (!('studyInstanceUID' in options)) {\n          throw new Error('Study Instance UID is required for retrieval of series metadata');\n        }\n\n        if (!('seriesInstanceUID' in options)) {\n          throw new Error('Series Instance UID is required for retrieval of series metadata');\n        }\n\n        console.log(\"retrieve metadata of series \".concat(options.seriesInstanceUID));\n        var url = this.baseURL + '/studies/' + options.studyInstanceUID + '/series/' + options.seriesInstanceUID + '/metadata';\n        return this._httpGetApplicationJson(url);\n      }\n      /**\n       * Searches for DICOM instances.\n       * @param {Object} options optional DICOM identifiers (choices: \"studyInstanceUID\", \"seriesInstanceUID\")\n       * @param {Object} queryParams optional query parameters (choices: \"fuzzymatching\", \"offset\", \"limit\" or any valid DICOM attribute identifier)\n       * @returns {Array} instance representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2b)\n       */\n\n    }, {\n      key: \"searchForInstances\",\n      value: function searchForInstances() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var url = this.baseURL;\n\n        if ('studyInstanceUID' in options) {\n          url += '/studies/' + options.studyInstanceUID;\n\n          if ('seriesInstanceUID' in options) {\n            console.log(\"search for instances of series \".concat(options.seriesInstanceUID));\n            url += '/series/' + options.seriesInstanceUID;\n          } else {\n            console.log(\"search for instances of study \".concat(options.studyInstanceUID));\n          }\n        } else {\n          console.log('search for instances');\n        }\n\n        url += '/instances';\n\n        if ('queryParams' in options) {\n          url += DICOMwebClient._parseQueryParameters(options.queryParams);\n        }\n\n        return this._httpGetApplicationJson(url);\n      }\n      /** Returns a WADO-URI URL for an instance\n       *\n       * @param {Object} options\n       * @returns {String} WADO-URI URL\n       */\n\n    }, {\n      key: \"buildInstanceWadoURIUrl\",\n      value: function buildInstanceWadoURIUrl(options) {\n        if (!('studyInstanceUID' in options)) {\n          throw new Error('Study Instance UID is required.');\n        }\n\n        if (!('seriesInstanceUID' in options)) {\n          throw new Error('Series Instance UID is required.');\n        }\n\n        if (!('sopInstanceUID' in options)) {\n          throw new Error('SOP Instance UID is required.');\n        }\n\n        var contentType = options.contentType || MIMETYPES.DICOM;\n        var transferSyntax = options.transferSyntax || '*';\n        var params = [];\n        params.push('requestType=WADO');\n        params.push(\"studyUID=\".concat(options.studyInstanceUID));\n        params.push(\"seriesUID=\".concat(options.seriesInstanceUID));\n        params.push(\"objectUID=\".concat(options.sopInstanceUID));\n        params.push(\"contentType=\".concat(contentType));\n        params.push(\"transferSyntax=\".concat(transferSyntax));\n        var paramString = params.join('&');\n        return \"\".concat(this.baseURL, \"?\").concat(paramString);\n      }\n      /**\n       * Retrieves metadata for a DICOM instance.\n       * @param {String} studyInstanceUID Study Instance UID\n       * @param {String} seriesInstanceUID Series Instance UID\n       * @param {String} sopInstanceUID SOP Instance UID\n       * @returns {Object} metadata elements in DICOM JSON format\n       */\n\n    }, {\n      key: \"retrieveInstanceMetadata\",\n      value: function retrieveInstanceMetadata(options) {\n        if (!('studyInstanceUID' in options)) {\n          throw new Error('Study Instance UID is required for retrieval of instance metadata');\n        }\n\n        if (!('seriesInstanceUID' in options)) {\n          throw new Error('Series Instance UID is required for retrieval of instance metadata');\n        }\n\n        if (!('sopInstanceUID' in options)) {\n          throw new Error('SOP Instance UID is required for retrieval of instance metadata');\n        }\n\n        console.log(\"retrieve metadata of instance \".concat(options.sopInstanceUID));\n        var url = this.baseURL + '/studies/' + options.studyInstanceUID + '/series/' + options.seriesInstanceUID + '/instances/' + options.sopInstanceUID + '/metadata';\n        return this._httpGetApplicationJson(url);\n      }\n      /**\n       * Retrieves frames for a DICOM instance.\n       * @param {String} studyInstanceUID Study Instance UID\n       * @param {String} seriesInstanceUID Series Instance UID\n       * @param {String} sopInstanceUID SOP Instance UID\n       * @param {Array} frameNumbers one-based index of frames\n       * @param {Object} options optional parameters (key \"imageSubtype\" to specify MIME image subtypes)\n       * @returns {Array} frame items as byte arrays of the pixel data element\n       */\n\n    }, {\n      key: \"retrieveInstanceFrames\",\n      value: function retrieveInstanceFrames(options) {\n        if (!('studyInstanceUID' in options)) {\n          throw new Error('Study Instance UID is required for retrieval of instance metadata');\n        }\n\n        if (!('seriesInstanceUID' in options)) {\n          throw new Error('Series Instance UID is required for retrieval of instance metadata');\n        }\n\n        if (!('sopInstanceUID' in options)) {\n          throw new Error('SOP Instance UID is required for retrieval of instance metadata');\n        }\n\n        if (!('frameNumbers' in options)) {\n          throw new Error('frame numbers are required for retrieval of instance frames');\n        }\n\n        console.log(\"retrieve frames \".concat(options.frameNumbers.toString(), \" of instance \").concat(options.sopInstanceUID));\n        var url = this.baseURL + '/studies/' + options.studyInstanceUID + '/series/' + options.seriesInstanceUID + '/instances/' + options.sopInstanceUID + '/frames/' + options.frameNumbers.toString(); // TODO: Easier if user just provided mimetype directly? What is the benefit of adding 'image/'?\n\n        var mimeType = options.imageSubType ? \"image/\".concat(options.imageSubType) : MIMETYPES.OCTET_STREAM;\n        return this._httpGetByMimeType(url, mimeType).then(multipartDecode);\n      }\n      /**\n       * Retrieves a DICOM instance.\n       *\n       * @param {String} studyInstanceUID Study Instance UID\n       * @param {String} seriesInstanceUID Series Instance UID\n       * @param {String} sopInstanceUID SOP Instance UID\n       * @returns {Arraybuffer} DICOM Part 10 file as Arraybuffer\n       */\n\n    }, {\n      key: \"retrieveInstance\",\n      value: function retrieveInstance(options) {\n        if (!('studyInstanceUID' in options)) {\n          throw new Error('Study Instance UID is required');\n        }\n\n        if (!('seriesInstanceUID' in options)) {\n          throw new Error('Series Instance UID is required');\n        }\n\n        if (!('sopInstanceUID' in options)) {\n          throw new Error('SOP Instance UID is required');\n        }\n\n        var url = this.baseURL + '/studies/' + options.studyInstanceUID + '/series/' + options.seriesInstanceUID + '/instances/' + options.sopInstanceUID;\n        return this._httpGetByMimeType(url, MIMETYPES.DICOM).then(multipartDecode).then(getFirstResult);\n      }\n      /**\n       * Retrieves a set of DICOM instance for a series.\n       *\n       * @param {String} studyInstanceUID Study Instance UID\n       * @param {String} seriesInstanceUID Series Instance UID\n       * @returns {Arraybuffer[]} Array of DICOM Part 10 files as Arraybuffers\n       */\n\n    }, {\n      key: \"retrieveSeries\",\n      value: function retrieveSeries(options) {\n        if (!('studyInstanceUID' in options)) {\n          throw new Error('Study Instance UID is required');\n        }\n\n        if (!('seriesInstanceUID' in options)) {\n          throw new Error('Series Instance UID is required');\n        }\n\n        var url = this.baseURL + '/studies/' + options.studyInstanceUID + '/series/' + options.seriesInstanceUID;\n        return this._httpGetByMimeType(url, MIMETYPES.DICOM).then(multipartDecode);\n      }\n      /**\n       * Retrieves a set of DICOM instance for a study.\n       *\n       * @param {String} studyInstanceUID Study Instance UID\n       * @returns {Arraybuffer[]} Array of DICOM Part 10 files as Arraybuffers\n       */\n\n    }, {\n      key: \"retrieveStudy\",\n      value: function retrieveStudy(options) {\n        if (!('studyInstanceUID' in options)) {\n          throw new Error('Study Instance UID is required');\n        }\n\n        var url = this.baseURL + '/studies/' + options.studyInstanceUID;\n        return this._httpGetByMimeType(url, MIMETYPES.DICOM).then(multipartDecode);\n      }\n      /**\n       * Retrieve and parse BulkData from a BulkDataURI location.\n       * Decodes the multipart encoded data and returns the resulting data\n       * as an ArrayBuffer.\n       *\n       * See http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.5.5.html\n       *\n       * @param {Object} options\n       * @return {Promise}\n       */\n\n    }, {\n      key: \"retrieveBulkData\",\n      value: function retrieveBulkData(options) {\n        if (!('BulkDataURI' in options)) {\n          throw new Error('BulkDataURI is required.');\n        }\n\n        return this._httpGetByMimeType(options.BulkDataURI, MIMETYPES.OCTET_STREAM).then(multipartDecode).then(getFirstResult);\n      }\n      /**\n       * Stores DICOM instances.\n       * @param {Array} datasets DICOM datasets of instances that should be stored in DICOM JSON format\n       * @param {Object} options optional parameters (key \"studyInstanceUID\" to only store instances of a given study)\n       */\n\n    }, {\n      key: \"storeInstances\",\n      value: function storeInstances(options) {\n        if (!('datasets' in options)) {\n          throw new Error('datasets are required for storing');\n        }\n\n        var url = \"\".concat(this.baseURL, \"/studies\");\n\n        if ('studyInstanceUID' in options) {\n          url += \"/\".concat(options.studyInstanceUID);\n        }\n\n        var _multipartEncode = multipartEncode(options.datasets),\n            data = _multipartEncode.data,\n            boundary = _multipartEncode.boundary;\n\n        var headers = {\n          'Content-Type': \"multipart/related; type=application/dicom; boundary=\".concat(boundary)\n        };\n        return this._httpPost(url, headers, data, options.progressCallback);\n      }\n    }], [{\n      key: \"_parseQueryParameters\",\n      value: function _parseQueryParameters() {\n        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var queryString = '?';\n        Object.keys(params).forEach(function (key, index) {\n          if (index !== 0) {\n            queryString += '&';\n          }\n\n          queryString += key + '=' + encodeURIComponent(params[key]);\n        });\n        return queryString;\n      }\n    }]);\n\n    return DICOMwebClient;\n  }();\n\n  function findSubstring(str, before, after) {\n    var beforeIndex = str.lastIndexOf(before) + before.length;\n\n    if (beforeIndex < before.length) {\n      return null;\n    }\n\n    if (after !== undefined) {\n      var afterIndex = str.lastIndexOf(after);\n\n      if (afterIndex < 0) {\n        return null;\n      } else {\n        return str.substring(beforeIndex, afterIndex);\n      }\n    }\n\n    return str.substring(beforeIndex);\n  }\n\n  function getStudyInstanceUIDFromUri(uri) {\n    var uid = findSubstring(uri, \"studies/\", \"/series\");\n\n    if (!uid) {\n      var uid = findSubstring(uri, \"studies/\");\n    }\n\n    if (!uid) {\n      console.debug('Study Instance UID could not be dertermined from URI \"' + uri + '\"');\n    }\n\n    return uid;\n  }\n\n  function getSeriesInstanceUIDFromUri(uri) {\n    var uid = findSubstring(uri, \"series/\", \"/instances\");\n\n    if (!uid) {\n      var uid = findSubstring(uri, \"series/\");\n    }\n\n    if (!uid) {\n      console.debug('Series Instance UID could not be dertermined from URI \"' + uri + '\"');\n    }\n\n    return uid;\n  }\n\n  function getSOPInstanceUIDFromUri(uri) {\n    var uid = findSubstring(uri, \"/instances/\", \"/frames\");\n\n    if (!uid) {\n      var uid = findSubstring(uri, \"/instances/\", \"/metadata\");\n    }\n\n    if (!uid) {\n      var uid = findSubstring(uri, \"/instances/\");\n    }\n\n    if (!uid) {\n      console.debug('SOP Instance UID could not be dertermined from URI\"' + uri + '\"');\n    }\n\n    return uid;\n  }\n\n  function getFrameNumbersFromUri(uri) {\n    var numbers = findSubstring(uri, \"/frames/\");\n\n    if (numbers === undefined) {\n      console.debug('Frames Numbers could not be dertermined from URI\"' + uri + '\"');\n    }\n\n    return numbers.split(',');\n  }\n\n  var version = '0.3.2';\n\n  var api = {\n    DICOMwebClient: DICOMwebClient\n  };\n  var utils = {\n    getStudyInstanceUIDFromUri: getStudyInstanceUIDFromUri,\n    getSeriesInstanceUIDFromUri: getSeriesInstanceUIDFromUri,\n    getSOPInstanceUIDFromUri: getSOPInstanceUIDFromUri,\n    getFrameNumbersFromUri: getFrameNumbersFromUri\n  };\n\n  exports.api = api;\n  exports.utils = utils;\n  exports.version = version;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=dicomweb-client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGljb213ZWItY2xpZW50L2J1aWxkL2RpY29td2ViLWNsaWVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWNvbXdlYi1jbGllbnQvYnVpbGQvZGljb213ZWItY2xpZW50LmpzPzcyNWUiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZmFjdG9yeSgoZ2xvYmFsLkRJQ09Nd2ViQ2xpZW50ID0ge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBfdHlwZW9mKG9iaik7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgVWludDhBcnJheSB0byBhIFN0cmluZy5cbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBhcnJheSB0aGF0IHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBhcnJheSBvZmZzZXQgaW4gY2FzZSBvbmx5IHN1YnNldCBvZiBhcnJheSBpdGVtcyBzaG91bGQgYmUgZXh0cmFjdGVkIChkZWZhdWx0OiAwKVxuICAgKiBAcGFyYW0ge051bWJlcn0gbGltaXQgbWF4aW11bSBudW1iZXIgb2YgYXJyYXkgaXRlbXMgdGhhdCBzaG91bGQgYmUgZXh0cmFjdGVkIChkZWZhdWx0cyB0byBsZW5ndGggb2YgYXJyYXkpXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiB1aW50OEFycmF5VG9TdHJpbmcoYXJyLCBvZmZzZXQsIGxpbWl0KSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgbGltaXQgPSBsaW1pdCB8fCBhcnIubGVuZ3RoIC0gb2Zmc2V0O1xuICAgIHZhciBzdHIgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCBvZmZzZXQgKyBsaW1pdDsgaSsrKSB7XG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgU3RyaW5nIHRvIGEgVWludDhBcnJheS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBzdHJpbmcgdGhhdCBzaG91bGQgYmUgY29udmVydGVkXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHN0cmluZ1RvVWludDhBcnJheShzdHIpIHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHN0ci5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIGFycltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnI7XG4gIH1cbiAgLyoqXG4gICAqIElkZW50aWZpZXMgdGhlIGJvdW5kYXJ5IGluIGEgbXVsdGlwYXJ0L3JlbGF0ZWQgbWVzc2FnZSBoZWFkZXIuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgbWVzc2FnZSBoZWFkZXJcbiAgICogQHJldHVybnMge1N0cmluZ30gYm91bmRhcnlcbiAgICovXG5cblxuICBmdW5jdGlvbiBpZGVudGlmeUJvdW5kYXJ5KGhlYWRlcikge1xuICAgIHZhciBwYXJ0cyA9IGhlYWRlci5zcGxpdCgnXFxyXFxuJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocGFydHNbaV0uc3Vic3RyKDAsIDIpID09PSAnLS0nKSB7XG4gICAgICAgIHJldHVybiBwYXJ0c1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGEgZ2l2ZW4gdG9rZW4gaXMgY29udGFpbmVkIGJ5IGEgbWVzc2FnZSBhdCBhIGdpdmVuIG9mZnNldC5cbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBtZXNzYWdlIG1lc3NhZ2UgY29udGVudFxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHRva2VuIHN1YnN0cmluZyB0aGF0IHNob3VsZCBiZSBwcmVzZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvZmZzZXQgb2Zmc2V0IGluIG1lc3NhZ2UgY29udGVudCBmcm9tIHdoZXJlIHNlYXJjaCBzaG91bGQgc3RhcnRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IHdoZXRoZXIgbWVzc2FnZSBjb250YWlucyB0b2tlbiBhdCBvZmZzZXRcbiAgICovXG5cblxuICBmdW5jdGlvbiBjb250YWluc1Rva2VuKG1lc3NhZ2UsIHRva2VuKSB7XG4gICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcblxuICAgIGlmIChtZXNzYWdlICsgdG9rZW4ubGVuZ3RoID4gbWVzc2FnZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBvZmZzZXQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2VuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodG9rZW5baV0gIT09IG1lc3NhZ2VbaW5kZXgrK10pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kcyBhIGdpdmVuIHRva2VuIGluIGEgbWVzc2FnZSBhdCBhIGdpdmVuIG9mZnNldC5cbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBtZXNzYWdlIG1lc3NhZ2UgY29udGVudFxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHRva2VuIHN1YnN0cmluZyB0aGF0IHNob3VsZCBiZSBmb3VuZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gb2Zmc2V0IG1lc3NhZ2UgYm9keSBvZmZzZXQgZnJvbSB3aGVyZSBzZWFyY2ggc2hvdWxkIHN0YXJ0XG4gICAqIEByZXR1cm5zIHtCb29sZWFufSB3aGV0aGVyIG1lc3NhZ2UgaGFzIGEgcGFydCBhdCBnaXZlbiBvZmZzZXQgb3Igbm90XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZmluZFRva2VuKG1lc3NhZ2UsIHRva2VuKSB7XG4gICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICB2YXIgbWVzc2FnZUxlbmd0aCA9IG1lc3NhZ2UubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IG9mZnNldDsgaSA8IG1lc3NhZ2VMZW5ndGg7IGkrKykge1xuICAgICAgLy8gSWYgdGhlIGZpcnN0IHZhbHVlIG9mIHRoZSBtZXNzYWdlIG1hdGNoZXNcbiAgICAgIC8vIHRoZSBmaXJzdCB2YWx1ZSBvZiB0aGUgdG9rZW4sIGNoZWNrIGlmXG4gICAgICAvLyB0aGlzIGlzIHRoZSBmdWxsIHRva2VuLlxuICAgICAgaWYgKG1lc3NhZ2VbaV0gPT09IHRva2VuWzBdKSB7XG4gICAgICAgIGlmIChjb250YWluc1Rva2VuKG1lc3NhZ2UsIHRva2VuLCBpKSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNdWx0aXBhcnRFbmNvZGVkRGF0YVxuICAgKiBAcHJvcGVydHkge0FycmF5QnVmZmVyfSBkYXRhIFRoZSBlbmNvZGVkIE11bHRpcGFydCBEYXRhXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBib3VuZGFyeSBUaGUgYm91bmRhcnkgdXNlZCB0byBkaXZpZGUgcGllY2VzIG9mIHRoZSBlbmNvZGVkIGRhdGFcbiAgICovXG5cbiAgLyoqXG4gICAqIEVuY29kZSBvbmUgb3IgbW9yZSBESUNPTSBkYXRhc2V0cyBpbnRvIGEgc2luZ2xlIGJvZHkgc28gaXQgY2FuIGJlXG4gICAqIHNlbnQgdXNpbmcgdGhlIE11bHRpcGFydCBDb250ZW50LVR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJbXX0gZGF0YXNldHMgQXJyYXkgY29udGFpbmluZyBlYWNoIGZpbGUgdG8gYmUgZW5jb2RlZCBpbiB0aGUgbXVsdGlwYXJ0IGJvZHksIHBhc3NlZCBhcyBBcnJheUJ1ZmZlcnMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbYm91bmRhcnldIE9wdGlvbmFsIHN0cmluZyB0byBkZWZpbmUgYSBib3VuZGFyeSBiZXR3ZWVuIGVhY2ggcGFydCBvZiB0aGUgbXVsdGlwYXJ0IGJvZHkuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCwgYSByYW5kb20gR1VJRCB3aWxsIGJlIGdlbmVyYXRlZC5cbiAgICogQHJldHVybiB7TXVsdGlwYXJ0RW5jb2RlZERhdGF9IFRoZSBNdWx0aXBhcnQgZW5jb2RlZCBkYXRhIHJldHVybmVkIGFzIGFuIE9iamVjdC4gVGhpcyBjb250YWlucyBib3RoIHRoZSBkYXRhIGl0c2VsZiwgYW5kIHRoZSBib3VuZGFyeSBzdHJpbmcgdXNlZCB0byBkaXZpZGUgaXQuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbXVsdGlwYXJ0RW5jb2RlKGRhdGFzZXRzKSB7XG4gICAgdmFyIGJvdW5kYXJ5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBndWlkKCk7XG4gICAgdmFyIGNvbnRlbnRUeXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnYXBwbGljYXRpb24vZGljb20nO1xuICAgIHZhciBjb250ZW50VHlwZVN0cmluZyA9IFwiQ29udGVudC1UeXBlOiBcIi5jb25jYXQoY29udGVudFR5cGUpO1xuICAgIHZhciBoZWFkZXIgPSBcIlxcclxcbi0tXCIuY29uY2F0KGJvdW5kYXJ5LCBcIlxcclxcblwiKS5jb25jYXQoY29udGVudFR5cGVTdHJpbmcsIFwiXFxyXFxuXFxyXFxuXCIpO1xuICAgIHZhciBmb290ZXIgPSBcIlxcclxcbi0tXCIuY29uY2F0KGJvdW5kYXJ5LCBcIi0tXCIpO1xuICAgIHZhciBoZWFkZXJBcnJheSA9IHN0cmluZ1RvVWludDhBcnJheShoZWFkZXIpO1xuICAgIHZhciBmb290ZXJBcnJheSA9IHN0cmluZ1RvVWludDhBcnJheShmb290ZXIpO1xuICAgIHZhciBoZWFkZXJMZW5ndGggPSBoZWFkZXJBcnJheS5sZW5ndGg7XG4gICAgdmFyIGZvb3Rlckxlbmd0aCA9IGZvb3RlckFycmF5Lmxlbmd0aDtcbiAgICB2YXIgbGVuZ3RoID0gMDsgLy8gQ2FsY3VsYXRlIHRoZSB0b3RhbCBsZW5ndGggZm9yIHRoZSBmaW5hbCBhcnJheVxuXG4gICAgdmFyIGNvbnRlbnRBcnJheXMgPSBkYXRhc2V0cy5tYXAoZnVuY3Rpb24gKGRhdGFzZXRCdWZmZXIpIHtcbiAgICAgIHZhciBjb250ZW50QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhc2V0QnVmZmVyKTtcbiAgICAgIHZhciBjb250ZW50TGVuZ3RoID0gY29udGVudEFycmF5Lmxlbmd0aDtcbiAgICAgIGxlbmd0aCArPSBoZWFkZXJMZW5ndGggKyBjb250ZW50TGVuZ3RoICsgZm9vdGVyTGVuZ3RoO1xuICAgICAgcmV0dXJuIGNvbnRlbnRBcnJheTtcbiAgICB9KTsgLy8gQWxsb2NhdGUgdGhlIGFycmF5XG5cbiAgICB2YXIgbXVsdGlwYXJ0QXJyYXkgPSBuZXcgVWludDhBcnJheShsZW5ndGgpOyAvLyBTZXQgdGhlIGluaXRpYWwgaGVhZGVyXG5cbiAgICBtdWx0aXBhcnRBcnJheS5zZXQoaGVhZGVyQXJyYXksIDApOyAvLyBXcml0ZSBlYWNoIGRhdGFzZXQgaW50byB0aGUgbXVsdGlwYXJ0IGFycmF5XG5cbiAgICB2YXIgcG9zaXRpb24gPSAwO1xuICAgIGNvbnRlbnRBcnJheXMuZm9yRWFjaChmdW5jdGlvbiAoY29udGVudEFycmF5KSB7XG4gICAgICB2YXIgY29udGVudExlbmd0aCA9IGNvbnRlbnRBcnJheS5sZW5ndGg7XG4gICAgICBtdWx0aXBhcnRBcnJheS5zZXQoaGVhZGVyQXJyYXksIHBvc2l0aW9uKTtcbiAgICAgIG11bHRpcGFydEFycmF5LnNldChjb250ZW50QXJyYXksIHBvc2l0aW9uICsgaGVhZGVyTGVuZ3RoKTtcbiAgICAgIHBvc2l0aW9uICs9IGhlYWRlckxlbmd0aCArIGNvbnRlbnRBcnJheS5sZW5ndGg7XG4gICAgfSk7XG4gICAgbXVsdGlwYXJ0QXJyYXkuc2V0KGZvb3RlckFycmF5LCBwb3NpdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IG11bHRpcGFydEFycmF5LmJ1ZmZlcixcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIERlY29kZSBhIE11bHRpcGFydCBlbmNvZGVkIEFycmF5QnVmZmVyIGFuZCByZXR1cm4gdGhlIGNvbXBvbmVudHMgYXMgYW4gQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IHJlc3BvbnNlIERhdGEgZW5jb2RlZCBhcyBhICdtdWx0aXBhcnQvcmVsYXRlZCcgbWVzc2FnZVxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBjb250ZW50XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG11bHRpcGFydERlY29kZShyZXNwb25zZSkge1xuICAgIHZhciBtZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UpOyAvLyBGaXJzdCBsb29rIGZvciB0aGUgbXVsdGlwYXJ0IG1pbWUgaGVhZGVyXG5cbiAgICB2YXIgc2VwYXJhdG9yID0gc3RyaW5nVG9VaW50OEFycmF5KCdcXHJcXG5cXHJcXG4nKTtcbiAgICB2YXIgaGVhZGVySW5kZXggPSBmaW5kVG9rZW4obWVzc2FnZSwgc2VwYXJhdG9yKTtcblxuICAgIGlmIChoZWFkZXJJbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVzcG9uc2UgbWVzc2FnZSBoYXMgbm8gbXVsdGlwYXJ0IG1pbWUgaGVhZGVyJyk7XG4gICAgfVxuXG4gICAgdmFyIGhlYWRlciA9IHVpbnQ4QXJyYXlUb1N0cmluZyhtZXNzYWdlLCAwLCBoZWFkZXJJbmRleCk7XG4gICAgdmFyIGJvdW5kYXJ5U3RyaW5nID0gaWRlbnRpZnlCb3VuZGFyeShoZWFkZXIpO1xuXG4gICAgaWYgKCFib3VuZGFyeVN0cmluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdIZWFkZXIgb2YgcmVzcG9uc2UgbWVzc2FnZSBkb2VzIG5vdCBzcGVjaWZ5IGJvdW5kYXJ5Jyk7XG4gICAgfVxuXG4gICAgdmFyIGJvdW5kYXJ5ID0gc3RyaW5nVG9VaW50OEFycmF5KGJvdW5kYXJ5U3RyaW5nKTtcbiAgICB2YXIgYm91bmRhcnlMZW5ndGggPSBib3VuZGFyeS5sZW5ndGg7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICB2YXIgb2Zmc2V0ID0gaGVhZGVySW5kZXggKyBzZXBhcmF0b3IubGVuZ3RoOyAvLyBMb29wIHVudGlsIHdlIGNhbm5vdCBmaW5kIGFueSBtb3JlIGJvdW5kYXJpZXNcblxuICAgIHZhciBib3VuZGFyeUluZGV4O1xuXG4gICAgd2hpbGUgKGJvdW5kYXJ5SW5kZXggIT09IC0xKSB7XG4gICAgICAvLyBTZWFyY2ggZm9yIHRoZSBuZXh0IGJvdW5kYXJ5IGluIHRoZSBtZXNzYWdlLCBzdGFydGluZ1xuICAgICAgLy8gZnJvbSB0aGUgY3VycmVudCBvZmZzZXQgcG9zaXRpb25cbiAgICAgIGJvdW5kYXJ5SW5kZXggPSBmaW5kVG9rZW4obWVzc2FnZSwgYm91bmRhcnksIG9mZnNldCk7IC8vIElmIG5vIGZ1cnRoZXIgYm91bmRhcmllcyBhcmUgZm91bmQsIHN0b3AgaGVyZS5cblxuICAgICAgaWYgKGJvdW5kYXJ5SW5kZXggPT09IC0xKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBFeHRyYWN0IGRhdGEgZnJvbSByZXNwb25zZSBtZXNzYWdlLCBleGNsdWRpbmcgXCJcXHJcXG5cIlxuXG5cbiAgICAgIHZhciBzcGFjaW5nTGVuZ3RoID0gMjtcbiAgICAgIHZhciBsZW5ndGggPSBib3VuZGFyeUluZGV4IC0gb2Zmc2V0IC0gc3BhY2luZ0xlbmd0aDtcbiAgICAgIHZhciBkYXRhID0gcmVzcG9uc2Uuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpOyAvLyBBZGQgdGhlIGRhdGEgdG8gdGhlIGFycmF5IG9mIHJlc3VsdHNcblxuICAgICAgY29tcG9uZW50cy5wdXNoKGRhdGEpOyAvLyBNb3ZlIHRoZSBvZmZzZXQgdG8gdGhlIGVuZCBvZiB0aGUgY3VycmVudCBzZWN0aW9uLFxuICAgICAgLy8gcGx1cyB0aGUgaWRlbnRpZmllZCBib3VuZGFyeVxuXG4gICAgICBvZmZzZXQgKz0gbGVuZ3RoICsgc3BhY2luZ0xlbmd0aCArIGJvdW5kYXJ5TGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiBjb21wb25lbnRzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSByYW5kb20gR1VJRFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ3VpZCgpIHtcbiAgICBmdW5jdGlvbiBzNCgpIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKCgxICsgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO1xuICAgIH1cblxuICAgIHJldHVybiBzNCgpICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArIHM0KCkgKyBzNCgpICsgczQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRW1wdHlPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuICB9XG5cbiAgdmFyIGdldEZpcnN0UmVzdWx0ID0gZnVuY3Rpb24gZ2V0Rmlyc3RSZXN1bHQocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgfTtcblxuICB2YXIgTUlNRVRZUEVTID0ge1xuICAgIERJQ09NOiAnYXBwbGljYXRpb24vZGljb20nLFxuICAgIERJQ09NX0pTT046ICdhcHBsaWNhdGlvbi9kaWNvbStqc29uJyxcbiAgICBPQ1RFVF9TVFJFQU06ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG4gIH07XG4gIC8qKlxuICAqIENsYXNzIGZvciBpbnRlcmFjdGluZyB3aXRoIERJQ09Nd2ViIFJFU1RmdWwgc2VydmljZXMuXG4gICovXG5cbiAgdmFyIERJQ09Nd2ViQ2xpZW50ID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgKiBAY29uc3RydWN0b3JcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIChjaG9pY2VzOiBcInVybFwiLCBcInVzZXJuYW1lXCIsIFwicGFzc3dvcmRcIiwgXCJoZWFkZXJzXCIpXG4gICAgKi9cbiAgICBmdW5jdGlvbiBESUNPTXdlYkNsaWVudChvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRElDT013ZWJDbGllbnQpO1xuXG4gICAgICB0aGlzLmJhc2VVUkwgPSBvcHRpb25zLnVybDtcblxuICAgICAgaWYgKCF0aGlzLmJhc2VVUkwpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRElDT013ZWIgYmFzZSB1cmwgcHJvdmlkZWQgLSBjYWxscyB3aWxsIGZhaWwnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCd1c2VybmFtZScgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzLnVzZXJuYW1lID0gb3B0aW9ucy51c2VybmFtZTtcblxuICAgICAgICBpZiAoISgncGFzc3dvcmQnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignbm8gcGFzc3dvcmQgcHJvdmlkZWQgdG8gYXV0aGVudGljYXRlIHdpdGggRElDT013ZWIgc2VydmljZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYXNzd29yZCA9IG9wdGlvbnMucGFzc3dvcmQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRElDT013ZWJDbGllbnQsIFt7XG4gICAgICBrZXk6IFwiX2h0dHBSZXF1ZXN0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2h0dHBSZXF1ZXN0KHVybCwgbWV0aG9kLCBoZWFkZXJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgcmVxdWVzdC5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcblxuICAgICAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IG9wdGlvbnMucmVzcG9uc2VUeXBlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfdHlwZW9mKGhlYWRlcnMpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IC8vIG5vdyBhZGQgY3VzdG9tIGhlYWRlcnMgZnJvbSB0aGUgdXNlclxuICAgICAgICAgIC8vIChlLmcuIGFjY2VzcyB0b2tlbnMpXG5cblxuICAgICAgICAgIHZhciB1c2VySGVhZGVycyA9IF90aGlzLmhlYWRlcnM7XG4gICAgICAgICAgT2JqZWN0LmtleXModXNlckhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdXNlckhlYWRlcnNba2V5XSk7XG4gICAgICAgICAgfSk7IC8vIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHVwbG9hZCBzdGFydHNcblxuICAgICAgICAgIHJlcXVlc3Qub25sb2Fkc3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHsvL2NvbnNvbGUubG9nKCd1cGxvYWQgc3RhcnRlZDogJywgdXJsKVxuICAgICAgICAgIH07IC8vIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHVwbG9hZCBlbmRzXG5cblxuICAgICAgICAgIHJlcXVlc3Qub25sb2FkZW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7Ly9jb25zb2xlLmxvZygndXBsb2FkIGZpbmlzaGVkJylcbiAgICAgICAgICB9OyAvLyBIYW5kbGUgcmVzcG9uc2UgbWVzc2FnZVxuXG5cbiAgICAgICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc29tZSByZXNvdXJjZXMgYWxyZWFkeSBleGlzdGVkOiAnLCByZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2VtcHR5IHJlc3BvbnNlIGZvciByZXF1ZXN0OiAnLCByZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdyZXF1ZXN0IGZhaWxlZDogJywgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdyZXF1ZXN0IGZhaWxlZCcpO1xuICAgICAgICAgICAgICAgIGVycm9yLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgIGVycm9yLnJlc3BvbnNlID0gcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICBlcnJvci5zdGF0dXMgPSByZXF1ZXN0LnN0YXR1cztcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTsgLy8gRXZlbnQgdHJpZ2dlcmVkIHdoaWxlIGRvd25sb2FkIHByb2dyZXNzZXNcblxuXG4gICAgICAgICAgaWYgKCdwcm9ncmVzc0NhbGxiYWNrJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMucHJvZ3Jlc3NDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBvcHRpb25zLnByb2dyZXNzQ2FsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAvLyAgIGNvbnN0IGxvYWRlZCA9IHByb2dyZXNzLmxvYWRlZDtcbiAgICAgICAgICAvLyAgIGxldCB0b3RhbDtcbiAgICAgICAgICAvLyAgIGxldCBwZXJjZW50Q29tcGxldGU7XG4gICAgICAgICAgLy8gICBpZiAocHJvZ3Jlc3MubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgIC8vICAgICB0b3RhbCA9IHByb2dyZXNzLnRvdGFsO1xuICAgICAgICAgIC8vICAgICBwZXJjZW50Q29tcGxldGUgPSBNYXRoLnJvdW5kKChsb2FkZWQgLyB0b3RhbCkgKiAxMDApO1xuICAgICAgICAgIC8vICAgalxuICAgICAgICAgIC8vICAgLy8gY29uc29sZS5sb2coJ2Rvd25sb2FkIHByb2dyZXNzOiAnLCBwZXJjZW50Q29tcGxldGUsICcgJScpO1xuICAgICAgICAgIC8vICAgcmV0dXJuKHBlcmNlbnRDb21wbGV0ZSk7XG4gICAgICAgICAgLy8gfTtcblxuXG4gICAgICAgICAgaWYgKCdkYXRhJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXF1ZXN0LnNlbmQob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2h0dHBHZXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaHR0cEdldCh1cmwsIGhlYWRlcnMsIHJlc3BvbnNlVHlwZSwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5faHR0cFJlcXVlc3QodXJsLCAnZ2V0JywgaGVhZGVycywge1xuICAgICAgICAgIHJlc3BvbnNlVHlwZTogcmVzcG9uc2VUeXBlLFxuICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2s6IHByb2dyZXNzQ2FsbGJhY2tcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9odHRwR2V0QXBwbGljYXRpb25Kc29uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2h0dHBHZXRBcHBsaWNhdGlvbkpzb24odXJsKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgICB2YXIgcHJvZ3Jlc3NDYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChfdHlwZW9mKHBhcmFtcykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKCFpc0VtcHR5T2JqZWN0KHBhcmFtcykpIHtcbiAgICAgICAgICAgIHVybCArPSBESUNPTXdlYkNsaWVudC5fcGFyc2VRdWVyeVBhcmFtZXRlcnMocGFyYW1zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGVhZGVycyA9IHtcbiAgICAgICAgICAnQWNjZXB0JzogTUlNRVRZUEVTLkRJQ09NX0pTT05cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2h0dHBHZXQodXJsLCBoZWFkZXJzLCByZXNwb25zZVR5cGUsIHByb2dyZXNzQ2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaHR0cEdldEJ5TWltZVR5cGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaHR0cEdldEJ5TWltZVR5cGUodXJsLCBtaW1lVHlwZSwgcGFyYW1zKSB7XG4gICAgICAgIHZhciByZXNwb25zZVR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIHZhciBwcm9ncmVzc0NhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKF90eXBlb2YocGFyYW1zKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpZiAoIWlzRW1wdHlPYmplY3QocGFyYW1zKSkge1xuICAgICAgICAgICAgdXJsICs9IERJQ09Nd2ViQ2xpZW50Ll9wYXJzZVF1ZXJ5UGFyYW1ldGVycyhwYXJhbXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoZWFkZXJzID0ge1xuICAgICAgICAgICdBY2NlcHQnOiBcIm11bHRpcGFydC9yZWxhdGVkOyB0eXBlPVxcXCJcIi5jb25jYXQobWltZVR5cGUsIFwiXFxcIlwiKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5faHR0cEdldCh1cmwsIGhlYWRlcnMsIHJlc3BvbnNlVHlwZSwgcHJvZ3Jlc3NDYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9odHRwUG9zdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9odHRwUG9zdCh1cmwsIGhlYWRlcnMsIGRhdGEsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2h0dHBSZXF1ZXN0KHVybCwgJ3Bvc3QnLCBoZWFkZXJzLCB7XG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrOiBwcm9ncmVzc0NhbGxiYWNrXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaHR0cFBvc3RBcHBsaWNhdGlvbkpzb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaHR0cFBvc3RBcHBsaWNhdGlvbkpzb24odXJsLCBkYXRhLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgIHZhciBoZWFkZXJzID0ge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiBNSU1FVFlQRVMuRElDT01fSlNPTlxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5faHR0cFBvc3QodXJsLCBoZWFkZXJzLCBkYXRhLCBwcm9ncmVzc0NhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogU2VhcmNoZXMgZm9yIERJQ09NIHN0dWRpZXMuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIG9iamVjdCAtIFwicXVlcnlQYXJhbXNcIiBvcHRpb25hbCBxdWVyeSBwYXJhbWV0ZXJzIChjaG9pY2VzOiBcImZ1enp5bWF0Y2hpbmdcIiwgXCJvZmZzZXRcIiwgXCJsaW1pdFwiIG9yIGFueSB2YWxpZCBESUNPTSBhdHRyaWJ1dGUgaWRlbnRpZmllcilcbiAgICAgICAqIEByZXR1cm4ge0FycmF5fSBzdHVkeSByZXByZXNlbnRhdGlvbnMgKGh0dHA6Ly9kaWNvbS5uZW1hLm9yZy9tZWRpY2FsL2RpY29tL2N1cnJlbnQvb3V0cHV0L2NodG1sL3BhcnQxOC9zZWN0XzYuNy5odG1sI3RhYmxlXzYuNy4xLTIpXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZWFyY2hGb3JTdHVkaWVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2VhcmNoRm9yU3R1ZGllcygpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICBjb25zb2xlLmxvZygnc2VhcmNoIGZvciBzdHVkaWVzJyk7XG4gICAgICAgIHZhciB1cmwgPSB0aGlzLmJhc2VVUkwgKyAnL3N0dWRpZXMnO1xuXG4gICAgICAgIGlmICgncXVlcnlQYXJhbXMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICB1cmwgKz0gRElDT013ZWJDbGllbnQuX3BhcnNlUXVlcnlQYXJhbWV0ZXJzKG9wdGlvbnMucXVlcnlQYXJhbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2h0dHBHZXRBcHBsaWNhdGlvbkpzb24odXJsKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogUmV0cmlldmVzIG1ldGFkYXRhIGZvciBhIERJQ09NIHN0dWR5LlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0dWR5SW5zdGFuY2VVSUQgU3R1ZHkgSW5zdGFuY2UgVUlEXG4gICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IG1ldGFkYXRhIGVsZW1lbnRzIGluIERJQ09NIEpTT04gZm9ybWF0IGZvciBlYWNoIGluc3RhbmNlIGJlbG9uZ2luZyB0byB0aGUgc3R1ZHlcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInJldHJpZXZlU3R1ZHlNZXRhZGF0YVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJldHJpZXZlU3R1ZHlNZXRhZGF0YShvcHRpb25zKSB7XG4gICAgICAgIGlmICghKCdzdHVkeUluc3RhbmNlVUlEJyBpbiBvcHRpb25zKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3R1ZHkgSW5zdGFuY2UgVUlEIGlzIHJlcXVpcmVkIGZvciByZXRyaWV2YWwgb2Ygc3R1ZHkgbWV0YWRhdGEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKFwicmV0cmlldmUgbWV0YWRhdGEgb2Ygc3R1ZHkgXCIuY29uY2F0KG9wdGlvbnMuc3R1ZHlJbnN0YW5jZVVJRCkpO1xuICAgICAgICB2YXIgdXJsID0gdGhpcy5iYXNlVVJMICsgJy9zdHVkaWVzLycgKyBvcHRpb25zLnN0dWR5SW5zdGFuY2VVSUQgKyAnL21ldGFkYXRhJztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2h0dHBHZXRBcHBsaWNhdGlvbkpzb24odXJsKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogU2VhcmNoZXMgZm9yIERJQ09NIHNlcmllcy5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbmFsIERJQ09NIGlkZW50aWZpZXJzIChjaG9pY2VzOiBcInN0dWR5SW5zdGFuY2VVSURcIilcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBxdWVyeVBhcmFtcyBvcHRpb25hbCBxdWVyeSBwYXJhbWV0ZXJzIChjaG9pY2VzOiBcImZ1enp5bWF0Y2hpbmdcIiwgXCJvZmZzZXRcIiwgXCJsaW1pdFwiIG9yIGFueSB2YWxpZCBESUNPTSBhdHRyaWJ1dGUgaWRlbnRpZmllcilcbiAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gc2VyaWVzIHJlcHJlc2VudGF0aW9ucyAoaHR0cDovL2RpY29tLm5lbWEub3JnL21lZGljYWwvZGljb20vY3VycmVudC9vdXRwdXQvY2h0bWwvcGFydDE4L3NlY3RfNi43Lmh0bWwjdGFibGVfNi43LjEtMmEpXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZWFyY2hGb3JTZXJpZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWFyY2hGb3JTZXJpZXMoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgdmFyIHVybCA9IHRoaXMuYmFzZVVSTDtcblxuICAgICAgICBpZiAoJ3N0dWR5SW5zdGFuY2VVSUQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcInNlYXJjaCBzZXJpZXMgb2Ygc3R1ZHkgXCIuY29uY2F0KG9wdGlvbnMuc3R1ZHlJbnN0YW5jZVVJRCkpO1xuICAgICAgICAgIHVybCArPSAnL3N0dWRpZXMvJyArIG9wdGlvbnMuc3R1ZHlJbnN0YW5jZVVJRDtcbiAgICAgICAgfVxuXG4gICAgICAgIHVybCArPSAnL3Nlcmllcyc7XG5cbiAgICAgICAgaWYgKCdxdWVyeVBhcmFtcycgaW4gb3B0aW9ucykge1xuICAgICAgICAgIHVybCArPSBESUNPTXdlYkNsaWVudC5fcGFyc2VRdWVyeVBhcmFtZXRlcnMob3B0aW9ucy5xdWVyeVBhcmFtcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faHR0cEdldEFwcGxpY2F0aW9uSnNvbih1cmwpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBSZXRyaWV2ZXMgbWV0YWRhdGEgZm9yIGEgRElDT00gc2VyaWVzLlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0dWR5SW5zdGFuY2VVSUQgU3R1ZHkgSW5zdGFuY2UgVUlEXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VyaWVzSW5zdGFuY2VVSUQgU2VyaWVzIEluc3RhbmNlIFVJRFxuICAgICAgICogQHJldHVybnMge0FycmF5fSBtZXRhZGF0YSBlbGVtZW50cyBpbiBESUNPTSBKU09OIGZvcm1hdCBmb3IgZWFjaCBpbnN0YW5jZSBiZWxvbmdpbmcgdG8gdGhlIHNlcmllc1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmV0cmlldmVTZXJpZXNNZXRhZGF0YVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJldHJpZXZlU2VyaWVzTWV0YWRhdGEob3B0aW9ucykge1xuICAgICAgICBpZiAoISgnc3R1ZHlJbnN0YW5jZVVJRCcgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0dWR5IEluc3RhbmNlIFVJRCBpcyByZXF1aXJlZCBmb3IgcmV0cmlldmFsIG9mIHNlcmllcyBtZXRhZGF0YScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoJ3Nlcmllc0luc3RhbmNlVUlEJyBpbiBvcHRpb25zKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VyaWVzIEluc3RhbmNlIFVJRCBpcyByZXF1aXJlZCBmb3IgcmV0cmlldmFsIG9mIHNlcmllcyBtZXRhZGF0YScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJyZXRyaWV2ZSBtZXRhZGF0YSBvZiBzZXJpZXMgXCIuY29uY2F0KG9wdGlvbnMuc2VyaWVzSW5zdGFuY2VVSUQpKTtcbiAgICAgICAgdmFyIHVybCA9IHRoaXMuYmFzZVVSTCArICcvc3R1ZGllcy8nICsgb3B0aW9ucy5zdHVkeUluc3RhbmNlVUlEICsgJy9zZXJpZXMvJyArIG9wdGlvbnMuc2VyaWVzSW5zdGFuY2VVSUQgKyAnL21ldGFkYXRhJztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2h0dHBHZXRBcHBsaWNhdGlvbkpzb24odXJsKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogU2VhcmNoZXMgZm9yIERJQ09NIGluc3RhbmNlcy5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbmFsIERJQ09NIGlkZW50aWZpZXJzIChjaG9pY2VzOiBcInN0dWR5SW5zdGFuY2VVSURcIiwgXCJzZXJpZXNJbnN0YW5jZVVJRFwiKVxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHF1ZXJ5UGFyYW1zIG9wdGlvbmFsIHF1ZXJ5IHBhcmFtZXRlcnMgKGNob2ljZXM6IFwiZnV6enltYXRjaGluZ1wiLCBcIm9mZnNldFwiLCBcImxpbWl0XCIgb3IgYW55IHZhbGlkIERJQ09NIGF0dHJpYnV0ZSBpZGVudGlmaWVyKVxuICAgICAgICogQHJldHVybnMge0FycmF5fSBpbnN0YW5jZSByZXByZXNlbnRhdGlvbnMgKGh0dHA6Ly9kaWNvbS5uZW1hLm9yZy9tZWRpY2FsL2RpY29tL2N1cnJlbnQvb3V0cHV0L2NodG1sL3BhcnQxOC9zZWN0XzYuNy5odG1sI3RhYmxlXzYuNy4xLTJiKVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2VhcmNoRm9ySW5zdGFuY2VzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2VhcmNoRm9ySW5zdGFuY2VzKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIHZhciB1cmwgPSB0aGlzLmJhc2VVUkw7XG5cbiAgICAgICAgaWYgKCdzdHVkeUluc3RhbmNlVUlEJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgdXJsICs9ICcvc3R1ZGllcy8nICsgb3B0aW9ucy5zdHVkeUluc3RhbmNlVUlEO1xuXG4gICAgICAgICAgaWYgKCdzZXJpZXNJbnN0YW5jZVVJRCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJzZWFyY2ggZm9yIGluc3RhbmNlcyBvZiBzZXJpZXMgXCIuY29uY2F0KG9wdGlvbnMuc2VyaWVzSW5zdGFuY2VVSUQpKTtcbiAgICAgICAgICAgIHVybCArPSAnL3Nlcmllcy8nICsgb3B0aW9ucy5zZXJpZXNJbnN0YW5jZVVJRDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJzZWFyY2ggZm9yIGluc3RhbmNlcyBvZiBzdHVkeSBcIi5jb25jYXQob3B0aW9ucy5zdHVkeUluc3RhbmNlVUlEKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdzZWFyY2ggZm9yIGluc3RhbmNlcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgdXJsICs9ICcvaW5zdGFuY2VzJztcblxuICAgICAgICBpZiAoJ3F1ZXJ5UGFyYW1zJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgdXJsICs9IERJQ09Nd2ViQ2xpZW50Ll9wYXJzZVF1ZXJ5UGFyYW1ldGVycyhvcHRpb25zLnF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9odHRwR2V0QXBwbGljYXRpb25Kc29uKHVybCk7XG4gICAgICB9XG4gICAgICAvKiogUmV0dXJucyBhIFdBRE8tVVJJIFVSTCBmb3IgYW4gaW5zdGFuY2VcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICogQHJldHVybnMge1N0cmluZ30gV0FETy1VUkkgVVJMXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJidWlsZEluc3RhbmNlV2Fkb1VSSVVybFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkSW5zdGFuY2VXYWRvVVJJVXJsKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEoJ3N0dWR5SW5zdGFuY2VVSUQnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHVkeSBJbnN0YW5jZSBVSUQgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISgnc2VyaWVzSW5zdGFuY2VVSUQnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJpZXMgSW5zdGFuY2UgVUlEIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoJ3NvcEluc3RhbmNlVUlEJyBpbiBvcHRpb25zKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU09QIEluc3RhbmNlIFVJRCBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250ZW50VHlwZSA9IG9wdGlvbnMuY29udGVudFR5cGUgfHwgTUlNRVRZUEVTLkRJQ09NO1xuICAgICAgICB2YXIgdHJhbnNmZXJTeW50YXggPSBvcHRpb25zLnRyYW5zZmVyU3ludGF4IHx8ICcqJztcbiAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgICBwYXJhbXMucHVzaCgncmVxdWVzdFR5cGU9V0FETycpO1xuICAgICAgICBwYXJhbXMucHVzaChcInN0dWR5VUlEPVwiLmNvbmNhdChvcHRpb25zLnN0dWR5SW5zdGFuY2VVSUQpKTtcbiAgICAgICAgcGFyYW1zLnB1c2goXCJzZXJpZXNVSUQ9XCIuY29uY2F0KG9wdGlvbnMuc2VyaWVzSW5zdGFuY2VVSUQpKTtcbiAgICAgICAgcGFyYW1zLnB1c2goXCJvYmplY3RVSUQ9XCIuY29uY2F0KG9wdGlvbnMuc29wSW5zdGFuY2VVSUQpKTtcbiAgICAgICAgcGFyYW1zLnB1c2goXCJjb250ZW50VHlwZT1cIi5jb25jYXQoY29udGVudFR5cGUpKTtcbiAgICAgICAgcGFyYW1zLnB1c2goXCJ0cmFuc2ZlclN5bnRheD1cIi5jb25jYXQodHJhbnNmZXJTeW50YXgpKTtcbiAgICAgICAgdmFyIHBhcmFtU3RyaW5nID0gcGFyYW1zLmpvaW4oJyYnKTtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMuYmFzZVVSTCwgXCI/XCIpLmNvbmNhdChwYXJhbVN0cmluZyk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFJldHJpZXZlcyBtZXRhZGF0YSBmb3IgYSBESUNPTSBpbnN0YW5jZS5cbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHVkeUluc3RhbmNlVUlEIFN0dWR5IEluc3RhbmNlIFVJRFxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNlcmllc0luc3RhbmNlVUlEIFNlcmllcyBJbnN0YW5jZSBVSURcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzb3BJbnN0YW5jZVVJRCBTT1AgSW5zdGFuY2UgVUlEXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBtZXRhZGF0YSBlbGVtZW50cyBpbiBESUNPTSBKU09OIGZvcm1hdFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmV0cmlldmVJbnN0YW5jZU1ldGFkYXRhXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmV0cmlldmVJbnN0YW5jZU1ldGFkYXRhKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEoJ3N0dWR5SW5zdGFuY2VVSUQnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHVkeSBJbnN0YW5jZSBVSUQgaXMgcmVxdWlyZWQgZm9yIHJldHJpZXZhbCBvZiBpbnN0YW5jZSBtZXRhZGF0YScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoJ3Nlcmllc0luc3RhbmNlVUlEJyBpbiBvcHRpb25zKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VyaWVzIEluc3RhbmNlIFVJRCBpcyByZXF1aXJlZCBmb3IgcmV0cmlldmFsIG9mIGluc3RhbmNlIG1ldGFkYXRhJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISgnc29wSW5zdGFuY2VVSUQnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTT1AgSW5zdGFuY2UgVUlEIGlzIHJlcXVpcmVkIGZvciByZXRyaWV2YWwgb2YgaW5zdGFuY2UgbWV0YWRhdGEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKFwicmV0cmlldmUgbWV0YWRhdGEgb2YgaW5zdGFuY2UgXCIuY29uY2F0KG9wdGlvbnMuc29wSW5zdGFuY2VVSUQpKTtcbiAgICAgICAgdmFyIHVybCA9IHRoaXMuYmFzZVVSTCArICcvc3R1ZGllcy8nICsgb3B0aW9ucy5zdHVkeUluc3RhbmNlVUlEICsgJy9zZXJpZXMvJyArIG9wdGlvbnMuc2VyaWVzSW5zdGFuY2VVSUQgKyAnL2luc3RhbmNlcy8nICsgb3B0aW9ucy5zb3BJbnN0YW5jZVVJRCArICcvbWV0YWRhdGEnO1xuICAgICAgICByZXR1cm4gdGhpcy5faHR0cEdldEFwcGxpY2F0aW9uSnNvbih1cmwpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBSZXRyaWV2ZXMgZnJhbWVzIGZvciBhIERJQ09NIGluc3RhbmNlLlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0dWR5SW5zdGFuY2VVSUQgU3R1ZHkgSW5zdGFuY2UgVUlEXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VyaWVzSW5zdGFuY2VVSUQgU2VyaWVzIEluc3RhbmNlIFVJRFxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNvcEluc3RhbmNlVUlEIFNPUCBJbnN0YW5jZSBVSURcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGZyYW1lTnVtYmVycyBvbmUtYmFzZWQgaW5kZXggb2YgZnJhbWVzXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25hbCBwYXJhbWV0ZXJzIChrZXkgXCJpbWFnZVN1YnR5cGVcIiB0byBzcGVjaWZ5IE1JTUUgaW1hZ2Ugc3VidHlwZXMpXG4gICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGZyYW1lIGl0ZW1zIGFzIGJ5dGUgYXJyYXlzIG9mIHRoZSBwaXhlbCBkYXRhIGVsZW1lbnRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInJldHJpZXZlSW5zdGFuY2VGcmFtZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXRyaWV2ZUluc3RhbmNlRnJhbWVzKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEoJ3N0dWR5SW5zdGFuY2VVSUQnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHVkeSBJbnN0YW5jZSBVSUQgaXMgcmVxdWlyZWQgZm9yIHJldHJpZXZhbCBvZiBpbnN0YW5jZSBtZXRhZGF0YScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoJ3Nlcmllc0luc3RhbmNlVUlEJyBpbiBvcHRpb25zKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VyaWVzIEluc3RhbmNlIFVJRCBpcyByZXF1aXJlZCBmb3IgcmV0cmlldmFsIG9mIGluc3RhbmNlIG1ldGFkYXRhJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISgnc29wSW5zdGFuY2VVSUQnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTT1AgSW5zdGFuY2UgVUlEIGlzIHJlcXVpcmVkIGZvciByZXRyaWV2YWwgb2YgaW5zdGFuY2UgbWV0YWRhdGEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKCdmcmFtZU51bWJlcnMnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmcmFtZSBudW1iZXJzIGFyZSByZXF1aXJlZCBmb3IgcmV0cmlldmFsIG9mIGluc3RhbmNlIGZyYW1lcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJyZXRyaWV2ZSBmcmFtZXMgXCIuY29uY2F0KG9wdGlvbnMuZnJhbWVOdW1iZXJzLnRvU3RyaW5nKCksIFwiIG9mIGluc3RhbmNlIFwiKS5jb25jYXQob3B0aW9ucy5zb3BJbnN0YW5jZVVJRCkpO1xuICAgICAgICB2YXIgdXJsID0gdGhpcy5iYXNlVVJMICsgJy9zdHVkaWVzLycgKyBvcHRpb25zLnN0dWR5SW5zdGFuY2VVSUQgKyAnL3Nlcmllcy8nICsgb3B0aW9ucy5zZXJpZXNJbnN0YW5jZVVJRCArICcvaW5zdGFuY2VzLycgKyBvcHRpb25zLnNvcEluc3RhbmNlVUlEICsgJy9mcmFtZXMvJyArIG9wdGlvbnMuZnJhbWVOdW1iZXJzLnRvU3RyaW5nKCk7IC8vIFRPRE86IEVhc2llciBpZiB1c2VyIGp1c3QgcHJvdmlkZWQgbWltZXR5cGUgZGlyZWN0bHk/IFdoYXQgaXMgdGhlIGJlbmVmaXQgb2YgYWRkaW5nICdpbWFnZS8nP1xuXG4gICAgICAgIHZhciBtaW1lVHlwZSA9IG9wdGlvbnMuaW1hZ2VTdWJUeXBlID8gXCJpbWFnZS9cIi5jb25jYXQob3B0aW9ucy5pbWFnZVN1YlR5cGUpIDogTUlNRVRZUEVTLk9DVEVUX1NUUkVBTTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2h0dHBHZXRCeU1pbWVUeXBlKHVybCwgbWltZVR5cGUpLnRoZW4obXVsdGlwYXJ0RGVjb2RlKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogUmV0cmlldmVzIGEgRElDT00gaW5zdGFuY2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0dWR5SW5zdGFuY2VVSUQgU3R1ZHkgSW5zdGFuY2UgVUlEXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VyaWVzSW5zdGFuY2VVSUQgU2VyaWVzIEluc3RhbmNlIFVJRFxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNvcEluc3RhbmNlVUlEIFNPUCBJbnN0YW5jZSBVSURcbiAgICAgICAqIEByZXR1cm5zIHtBcnJheWJ1ZmZlcn0gRElDT00gUGFydCAxMCBmaWxlIGFzIEFycmF5YnVmZmVyXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZXRyaWV2ZUluc3RhbmNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmV0cmlldmVJbnN0YW5jZShvcHRpb25zKSB7XG4gICAgICAgIGlmICghKCdzdHVkeUluc3RhbmNlVUlEJyBpbiBvcHRpb25zKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3R1ZHkgSW5zdGFuY2UgVUlEIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISgnc2VyaWVzSW5zdGFuY2VVSUQnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJpZXMgSW5zdGFuY2UgVUlEIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISgnc29wSW5zdGFuY2VVSUQnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTT1AgSW5zdGFuY2UgVUlEIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXJsID0gdGhpcy5iYXNlVVJMICsgJy9zdHVkaWVzLycgKyBvcHRpb25zLnN0dWR5SW5zdGFuY2VVSUQgKyAnL3Nlcmllcy8nICsgb3B0aW9ucy5zZXJpZXNJbnN0YW5jZVVJRCArICcvaW5zdGFuY2VzLycgKyBvcHRpb25zLnNvcEluc3RhbmNlVUlEO1xuICAgICAgICByZXR1cm4gdGhpcy5faHR0cEdldEJ5TWltZVR5cGUodXJsLCBNSU1FVFlQRVMuRElDT00pLnRoZW4obXVsdGlwYXJ0RGVjb2RlKS50aGVuKGdldEZpcnN0UmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogUmV0cmlldmVzIGEgc2V0IG9mIERJQ09NIGluc3RhbmNlIGZvciBhIHNlcmllcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3R1ZHlJbnN0YW5jZVVJRCBTdHVkeSBJbnN0YW5jZSBVSURcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXJpZXNJbnN0YW5jZVVJRCBTZXJpZXMgSW5zdGFuY2UgVUlEXG4gICAgICAgKiBAcmV0dXJucyB7QXJyYXlidWZmZXJbXX0gQXJyYXkgb2YgRElDT00gUGFydCAxMCBmaWxlcyBhcyBBcnJheWJ1ZmZlcnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInJldHJpZXZlU2VyaWVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmV0cmlldmVTZXJpZXMob3B0aW9ucykge1xuICAgICAgICBpZiAoISgnc3R1ZHlJbnN0YW5jZVVJRCcgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0dWR5IEluc3RhbmNlIFVJRCBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoJ3Nlcmllc0luc3RhbmNlVUlEJyBpbiBvcHRpb25zKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VyaWVzIEluc3RhbmNlIFVJRCBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVybCA9IHRoaXMuYmFzZVVSTCArICcvc3R1ZGllcy8nICsgb3B0aW9ucy5zdHVkeUluc3RhbmNlVUlEICsgJy9zZXJpZXMvJyArIG9wdGlvbnMuc2VyaWVzSW5zdGFuY2VVSUQ7XG4gICAgICAgIHJldHVybiB0aGlzLl9odHRwR2V0QnlNaW1lVHlwZSh1cmwsIE1JTUVUWVBFUy5ESUNPTSkudGhlbihtdWx0aXBhcnREZWNvZGUpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBSZXRyaWV2ZXMgYSBzZXQgb2YgRElDT00gaW5zdGFuY2UgZm9yIGEgc3R1ZHkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0dWR5SW5zdGFuY2VVSUQgU3R1ZHkgSW5zdGFuY2UgVUlEXG4gICAgICAgKiBAcmV0dXJucyB7QXJyYXlidWZmZXJbXX0gQXJyYXkgb2YgRElDT00gUGFydCAxMCBmaWxlcyBhcyBBcnJheWJ1ZmZlcnNcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInJldHJpZXZlU3R1ZHlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXRyaWV2ZVN0dWR5KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEoJ3N0dWR5SW5zdGFuY2VVSUQnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHVkeSBJbnN0YW5jZSBVSUQgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1cmwgPSB0aGlzLmJhc2VVUkwgKyAnL3N0dWRpZXMvJyArIG9wdGlvbnMuc3R1ZHlJbnN0YW5jZVVJRDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2h0dHBHZXRCeU1pbWVUeXBlKHVybCwgTUlNRVRZUEVTLkRJQ09NKS50aGVuKG11bHRpcGFydERlY29kZSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFJldHJpZXZlIGFuZCBwYXJzZSBCdWxrRGF0YSBmcm9tIGEgQnVsa0RhdGFVUkkgbG9jYXRpb24uXG4gICAgICAgKiBEZWNvZGVzIHRoZSBtdWx0aXBhcnQgZW5jb2RlZCBkYXRhIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgZGF0YVxuICAgICAgICogYXMgYW4gQXJyYXlCdWZmZXIuXG4gICAgICAgKlxuICAgICAgICogU2VlIGh0dHA6Ly9kaWNvbS5uZW1hLm9yZy9tZWRpY2FsL2RpY29tL2N1cnJlbnQvb3V0cHV0L2NodG1sL3BhcnQxOC9zZWN0XzYuNS41Lmh0bWxcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInJldHJpZXZlQnVsa0RhdGFcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXRyaWV2ZUJ1bGtEYXRhKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEoJ0J1bGtEYXRhVVJJJyBpbiBvcHRpb25zKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQnVsa0RhdGFVUkkgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faHR0cEdldEJ5TWltZVR5cGUob3B0aW9ucy5CdWxrRGF0YVVSSSwgTUlNRVRZUEVTLk9DVEVUX1NUUkVBTSkudGhlbihtdWx0aXBhcnREZWNvZGUpLnRoZW4oZ2V0Rmlyc3RSZXN1bHQpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBTdG9yZXMgRElDT00gaW5zdGFuY2VzLlxuICAgICAgICogQHBhcmFtIHtBcnJheX0gZGF0YXNldHMgRElDT00gZGF0YXNldHMgb2YgaW5zdGFuY2VzIHRoYXQgc2hvdWxkIGJlIHN0b3JlZCBpbiBESUNPTSBKU09OIGZvcm1hdFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb3B0aW9uYWwgcGFyYW1ldGVycyAoa2V5IFwic3R1ZHlJbnN0YW5jZVVJRFwiIHRvIG9ubHkgc3RvcmUgaW5zdGFuY2VzIG9mIGEgZ2l2ZW4gc3R1ZHkpXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdG9yZUluc3RhbmNlc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3JlSW5zdGFuY2VzKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEoJ2RhdGFzZXRzJyBpbiBvcHRpb25zKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGF0YXNldHMgYXJlIHJlcXVpcmVkIGZvciBzdG9yaW5nJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXJsID0gXCJcIi5jb25jYXQodGhpcy5iYXNlVVJMLCBcIi9zdHVkaWVzXCIpO1xuXG4gICAgICAgIGlmICgnc3R1ZHlJbnN0YW5jZVVJRCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgIHVybCArPSBcIi9cIi5jb25jYXQob3B0aW9ucy5zdHVkeUluc3RhbmNlVUlEKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfbXVsdGlwYXJ0RW5jb2RlID0gbXVsdGlwYXJ0RW5jb2RlKG9wdGlvbnMuZGF0YXNldHMpLFxuICAgICAgICAgICAgZGF0YSA9IF9tdWx0aXBhcnRFbmNvZGUuZGF0YSxcbiAgICAgICAgICAgIGJvdW5kYXJ5ID0gX211bHRpcGFydEVuY29kZS5ib3VuZGFyeTtcblxuICAgICAgICB2YXIgaGVhZGVycyA9IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogXCJtdWx0aXBhcnQvcmVsYXRlZDsgdHlwZT1hcHBsaWNhdGlvbi9kaWNvbTsgYm91bmRhcnk9XCIuY29uY2F0KGJvdW5kYXJ5KVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5faHR0cFBvc3QodXJsLCBoZWFkZXJzLCBkYXRhLCBvcHRpb25zLnByb2dyZXNzQ2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcIl9wYXJzZVF1ZXJ5UGFyYW1ldGVyc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZVF1ZXJ5UGFyYW1ldGVycygpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIHZhciBxdWVyeVN0cmluZyA9ICc/JztcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGluZGV4KSB7XG4gICAgICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICBxdWVyeVN0cmluZyArPSAnJic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcXVlcnlTdHJpbmcgKz0ga2V5ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtc1trZXldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBxdWVyeVN0cmluZztcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRElDT013ZWJDbGllbnQ7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBmaW5kU3Vic3RyaW5nKHN0ciwgYmVmb3JlLCBhZnRlcikge1xuICAgIHZhciBiZWZvcmVJbmRleCA9IHN0ci5sYXN0SW5kZXhPZihiZWZvcmUpICsgYmVmb3JlLmxlbmd0aDtcblxuICAgIGlmIChiZWZvcmVJbmRleCA8IGJlZm9yZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChhZnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgYWZ0ZXJJbmRleCA9IHN0ci5sYXN0SW5kZXhPZihhZnRlcik7XG5cbiAgICAgIGlmIChhZnRlckluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKGJlZm9yZUluZGV4LCBhZnRlckluZGV4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZyhiZWZvcmVJbmRleCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTdHVkeUluc3RhbmNlVUlERnJvbVVyaSh1cmkpIHtcbiAgICB2YXIgdWlkID0gZmluZFN1YnN0cmluZyh1cmksIFwic3R1ZGllcy9cIiwgXCIvc2VyaWVzXCIpO1xuXG4gICAgaWYgKCF1aWQpIHtcbiAgICAgIHZhciB1aWQgPSBmaW5kU3Vic3RyaW5nKHVyaSwgXCJzdHVkaWVzL1wiKTtcbiAgICB9XG5cbiAgICBpZiAoIXVpZCkge1xuICAgICAgY29uc29sZS5kZWJ1ZygnU3R1ZHkgSW5zdGFuY2UgVUlEIGNvdWxkIG5vdCBiZSBkZXJ0ZXJtaW5lZCBmcm9tIFVSSSBcIicgKyB1cmkgKyAnXCInKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdWlkO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2VyaWVzSW5zdGFuY2VVSURGcm9tVXJpKHVyaSkge1xuICAgIHZhciB1aWQgPSBmaW5kU3Vic3RyaW5nKHVyaSwgXCJzZXJpZXMvXCIsIFwiL2luc3RhbmNlc1wiKTtcblxuICAgIGlmICghdWlkKSB7XG4gICAgICB2YXIgdWlkID0gZmluZFN1YnN0cmluZyh1cmksIFwic2VyaWVzL1wiKTtcbiAgICB9XG5cbiAgICBpZiAoIXVpZCkge1xuICAgICAgY29uc29sZS5kZWJ1ZygnU2VyaWVzIEluc3RhbmNlIFVJRCBjb3VsZCBub3QgYmUgZGVydGVybWluZWQgZnJvbSBVUkkgXCInICsgdXJpICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVpZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNPUEluc3RhbmNlVUlERnJvbVVyaSh1cmkpIHtcbiAgICB2YXIgdWlkID0gZmluZFN1YnN0cmluZyh1cmksIFwiL2luc3RhbmNlcy9cIiwgXCIvZnJhbWVzXCIpO1xuXG4gICAgaWYgKCF1aWQpIHtcbiAgICAgIHZhciB1aWQgPSBmaW5kU3Vic3RyaW5nKHVyaSwgXCIvaW5zdGFuY2VzL1wiLCBcIi9tZXRhZGF0YVwiKTtcbiAgICB9XG5cbiAgICBpZiAoIXVpZCkge1xuICAgICAgdmFyIHVpZCA9IGZpbmRTdWJzdHJpbmcodXJpLCBcIi9pbnN0YW5jZXMvXCIpO1xuICAgIH1cblxuICAgIGlmICghdWlkKSB7XG4gICAgICBjb25zb2xlLmRlYnVnKCdTT1AgSW5zdGFuY2UgVUlEIGNvdWxkIG5vdCBiZSBkZXJ0ZXJtaW5lZCBmcm9tIFVSSVwiJyArIHVyaSArICdcIicpO1xuICAgIH1cblxuICAgIHJldHVybiB1aWQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGcmFtZU51bWJlcnNGcm9tVXJpKHVyaSkge1xuICAgIHZhciBudW1iZXJzID0gZmluZFN1YnN0cmluZyh1cmksIFwiL2ZyYW1lcy9cIik7XG5cbiAgICBpZiAobnVtYmVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLmRlYnVnKCdGcmFtZXMgTnVtYmVycyBjb3VsZCBub3QgYmUgZGVydGVybWluZWQgZnJvbSBVUklcIicgKyB1cmkgKyAnXCInKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtYmVycy5zcGxpdCgnLCcpO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSAnMC4zLjInO1xuXG4gIHZhciBhcGkgPSB7XG4gICAgRElDT013ZWJDbGllbnQ6IERJQ09Nd2ViQ2xpZW50XG4gIH07XG4gIHZhciB1dGlscyA9IHtcbiAgICBnZXRTdHVkeUluc3RhbmNlVUlERnJvbVVyaTogZ2V0U3R1ZHlJbnN0YW5jZVVJREZyb21VcmksXG4gICAgZ2V0U2VyaWVzSW5zdGFuY2VVSURGcm9tVXJpOiBnZXRTZXJpZXNJbnN0YW5jZVVJREZyb21VcmksXG4gICAgZ2V0U09QSW5zdGFuY2VVSURGcm9tVXJpOiBnZXRTT1BJbnN0YW5jZVVJREZyb21VcmksXG4gICAgZ2V0RnJhbWVOdW1iZXJzRnJvbVVyaTogZ2V0RnJhbWVOdW1iZXJzRnJvbVVyaVxuICB9O1xuXG4gIGV4cG9ydHMuYXBpID0gYXBpO1xuICBleHBvcnRzLnV0aWxzID0gdXRpbHM7XG4gIGV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpY29td2ViLWNsaWVudC5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLFdBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/dicomweb-client/build/dicomweb-client.js\n")}}]);